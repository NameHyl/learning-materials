<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>1</h1>
    <h1>1</h1>
    <h1>1</h1>
    <h1>1</h1>
    <h1>1</h1>
    <h1>1</h1>
    <h1>1</h1>
    <h1>1</h1>
    <h1>1</h1>
    <h1>1</h1>
    <h1>1</h1>
    <h1>1</h1>
    <h1>1</h1>
    <h1>1</h1>
    <h1>1</h1>
    <h1>1</h1>
    <h1>1</h1>
    <h1>1</h1>
    <h1>1</h1>
    <h1>1</h1>
    <h1>1</h1>
    <h1>1</h1>
    <h1>1</h1>
    <h1>1</h1>
    <h1>1</h1>
    <h1>1</h1>
    <h1>1</h1>
    <h1>1</h1>
    <h1>1</h1>
    <img data-src="./image/pen.gif" alt="" />
  </body>
  <!-- 1.通过 InterSectionObserver造的对象来观察目标与视口是否有交叉，来决定是否让 img 有 src。 -->
  <script>
    // 观察对象
    const imgs = document.querySelectorAll('img');
    const callback = (entries) => {
      entries.forEach((entry) => {
        const data_src = entry.target.getAttribute('data-src');
        entry.target.setAttribute('src', data_src);
        // 清除observe
        observer.unobserve(entry.target);
        console.log('执行');
      });
    };
    const observer = new IntersectionObserver(callback, options);
    // 一些配置参数
    const options = {
      // root 目标元素所在的容器节点，如果不指定根节点，默认文档为根节点。
      // root: document.querySelector('#scroll'),
      // rootMargin 围绕根元素的边距，类似于css的margin属性。注意这个单位为px
      // rootMargin: '0px',
      // threshold 相交的比例，既可以是一个数字也可以是一个数组。取值在0-1之间。
      // threshold: [0],
    };
    imgs.forEach((image) => {
      // 被观察的元素
      observer.observe(image);
    });
  </script>
  <!-- 2.另一种实现是通过监听每个目标距离 document 顶部距离以及 document 滚出视口的距离差来判断是否向 img 写入 src 值。 -->
  <!-- <script></script> -->
</html>
